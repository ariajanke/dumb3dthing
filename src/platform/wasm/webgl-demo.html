<!doctype html>
<html lang="en-us">
<head>
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>WASM AABB Physics Demo SPA</title>
    
    <script
        src="https://code.jquery.com/jquery-3.6.0.min.js"
        integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4="
        crossorigin="anonymous"></script>
    
</head><body>

<div id="canvas-parent">
    <div id="menus" class="on-pause"></div>
    <div class="emscripten_border">
        <canvas class="emscripten" id="canvas" oncontextmenu="event.preventDefault()" tabindex=-1 width="800" height="800"></canvas>
    </div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"
integrity="sha512-zhHQR0/H5SEBL3Wn6yYSaTTZej12z0hVZKOv3TwCUXT1z5qeqGcXJLLrbERYRScEDDpYIJhPC1fk31gqR783iQ=="
crossorigin="anonymous" defer>
</script>
<script src="jsPlatform.js"></script>
<script type='text/javascript' defer>
// Platform driver:
// sends events (key inputs, clock tick)

// shader source pulled straight from... the bin folder
//
// My shaders are not compatible... :c

// Render Models have three components:
// - positions
// - texture positions
// - element indicies


const vsSource = `
attribute vec4 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat4 uModelViewMatrix;
uniform mat4 uProjectionMatrix;

varying highp vec2 vTextureCoord;
void main(void) {
  gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
  vTextureCoord = aTextureCoord;
}
`;

const fsSource = `
varying highp vec2 vTextureCoord;
uniform sampler2D uSampler;
void main(void) {
  gl_FragColor = texture2D(uSampler, vTextureCoord);
}
`;

window.onload = () => {
  const canvas = document.querySelector('#canvas');
  if (!canvas) {
    console.log('Cannot find the canvas.');
    return;
  }
  const gl = canvas.getContext('webgl');
  gl.clearColor(0.1, 0.6, 0.1, 1);
  gl.clear(gl.COLOR_BUFFER_BIT);

  const shaderProgram = initShaderProgram(gl, vsSource, fsSource);
  const programInfo = {
    program: shaderProgram,
    attribLocations: {
      vertexPosition: gl.getAttribLocation(shaderProgram, "aVertexPosition"),
      textureCoord: gl.getAttribLocation(shaderProgram, "aTextureCoord"),
    },
    uniformLocations: {
      projectionMatrix: gl.getUniformLocation(
        shaderProgram,
        "uProjectionMatrix"
      ),
      modelViewMatrix: gl.getUniformLocation(shaderProgram, "uModelViewMatrix"),
      uSampler: gl.getUniformLocation(shaderProgram, "uSampler"),
    }
  };
  
  jsPlatform.setContext(gl);
  const texture = jsPlatform.getTexture(jsPlatform.createTexture());
  texture.load('ground.png');
  texture.setUnit(0);
  const renderModel = jsPlatform.getRenderModel(jsPlatform.createRenderModel());
  renderModel.loadFromJsArrays([ // positions
    // Front face
    -1.0, -1.0,  1.0,
    1.0, -1.0,  1.0,
    1.0,  1.0,  1.0,
    -1.0,  1.0,  1.0,

    // Back face
    -1.0, -1.0, -1.0,
    -1.0,  1.0, -1.0,
    1.0,  1.0, -1.0,
    1.0, -1.0, -1.0,

    // Top face
    -1.0,  1.0, -1.0,
    -1.0,  1.0,  1.0,
    1.0,  1.0,  1.0,
    1.0,  1.0, -1.0,

    // Bottom face
    -1.0, -1.0, -1.0,
    1.0, -1.0, -1.0,
    1.0, -1.0,  1.0,
    -1.0, -1.0,  1.0,

    // Right face
    1.0, -1.0, -1.0,
    1.0,  1.0, -1.0,
    1.0,  1.0,  1.0,
    1.0, -1.0,  1.0,

    // Left face
    -1.0, -1.0, -1.0,
    -1.0, -1.0,  1.0,
    -1.0,  1.0,  1.0,
    -1.0,  1.0, -1.0,
  ], [ // texture positions
    // Front
    0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0,
    // Back
    0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0,
    // Top
    0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0,
    // Bottom
    0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0,
    // Right
    0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0,
    // Left
    0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0,
  ], [ // elements
    0,  1,  2,      0,  2,  3,    // front
    4,  5,  6,      4,  6,  7,    // back
    8,  9,  10,     8,  10, 11,   // top
    12, 13, 14,     12, 14, 15,   // bottom
    16, 17, 18,     16, 18, 19,   // right
    20, 21, 22,     20, 22, 23,   // left
  ]);
  // Browsers copy pixels from the loaded image in top-to-bottom order —
  // from the top-left corner; but WebGL wants the pixels in bottom-to-top
  // order — starting from the bottom-left corner. So in order to prevent
  // the resulting image texture from having the wrong orientation when
  // rendered, we need to make the following call, to cause the pixels to
  // be flipped into the bottom-to-top order that WebGL expects.
  // See jameshfisher.com/2020/10/22/why-is-my-webgl-texture-upside-down
  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);

  // platform has a lot of "must sets"
  // but this greatly eases things in the main cpp file
  // afterall the jsPlatform is supposed to take care of everything on the js 
  // side for C++
  jsPlatform.modelMatrix.setApplier(matrix => {
    gl.uniformMatrix4fv(
      programInfo.uniformLocations.modelViewMatrix,
      false, matrix);
  });
  jsPlatform.projectionMatrix.setReseter(() => {
    const fieldOfView = 45 * Math.PI / 180;   // in radians
    const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
    const zNear = 0.1;
    const zFar = 100.0;
    const projectionMatrix = mat4.create();

    // note: glmatrix.js always has the first argument
    // as the destination to receive the result.
    mat4.perspective(projectionMatrix, fieldOfView, aspect, zNear, zFar);
    return projectionMatrix;
  });
  jsPlatform.projectionMatrix.setApplier(matrix => {
    gl.uniformMatrix4fv(
      programInfo.uniformLocations.projectionMatrix,
      false, matrix);
  });
  jsPlatform.setRenderModelAttributes(
    programInfo.attribLocations.vertexPosition,
    programInfo.attribLocations.textureCoord);
  jsPlatform.setTextureUnitHandler(unit =>
    gl.uniform1i(programInfo.uniformLocations.uSampler, unit));

  let rotation = 0;
  let prevTime = 0;
  setInterval(now => {
    now *= 0.001;
    const delta = now - prevTime;
    rotation += 0.050;
    drawScene(gl, programInfo, { renderModel }, rotation, texture);
    prevTime = now;
  }, 50);
};

function drawScene(gl, programInfo, buffers, rotation, texture) {
  gl.clearColor(0.0, 0.0, 0.0, 1.0);  // Clear to black, fully opaque
  gl.clearDepth(1.0);                 // Clear everything
  gl.enable(gl.DEPTH_TEST);           // Enable depth testing
  gl.depthFunc(gl.LEQUAL);            // Near things obscure far things

  // Clear the canvas before we start drawing on it.

  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

  // Create a perspective matrix, a special matrix that is
  // used to simulate the distortion of perspective in a camera.
  // Our field of view is 45 degrees, with a width/height
  // ratio that matches the display size of the canvas
  // and we only want to see objects between 0.1 units
  // and 100 units away from the camera.

  jsPlatform.projectionMatrix.reset();
  
  jsPlatform.modelMatrix.reset();
  
  jsPlatform.modelMatrix.translate([0, 0, -6]);
  jsPlatform.modelMatrix.rotateY(rotation*0.7);

  jsPlatform.modelMatrix.rotateZ(rotation);
  jsPlatform.modelMatrix.rotateX(rotation*0.3)

  // Tell WebGL to use our program when drawing
  gl.useProgram(programInfo.program);

  jsPlatform.projectionMatrix.apply();
  jsPlatform.modelMatrix.apply();

  jsPlatform.bindTexture(0);
  jsPlatform.renderRenderModel(0);
}
const loadShader = (gl, type, source) => {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    // already at a fork of sorts... should I use helper libraries
    // so I can use monads and things like that?
    console.log(`Failed to compile shader: ${gl.getShaderInfoLog(shader)}`);
    gl.deleteShader(shader);
    return null; 
  }
  return shader;
};

const initShaderProgram = (gl, vsSource, fsSource) => {
  const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
  const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);

  const shaderProgram = gl.createProgram();
  gl.attachShader(shaderProgram, vertexShader);
  gl.attachShader(shaderProgram, fragmentShader);
  gl.linkProgram(shaderProgram);

  if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
    console.log(`Unable to initialize the shader program: ${gl.getProgramInfoLog(shaderProgram)}`);
    return null;
  }

  return shaderProgram;
};
</script>

</body></html>